<!-- 
이미지 병합 아이디어를 이용하여 적용해보았으나 결과가 별로임.
전부 병합 실패가 콘솔에 떠서 이미지 분할 개수를 늘리고 시각화 과정을 추가할 예정    

<!DOCTYPE html>
<html>
<head>
  <title>Teachable Machine Image Classifier</title>
  <style>
    #results-container {
      margin-top: 20px;
    }

    #results-table {
      border-collapse: collapse;
      width: 100%;
    }

    #results-table th, #results-table td {
      border: 1px solid black;
      padding: 5px;
      text-align: center;
    }

    #results-table th {
      background-color: #f2f2f2;
    }

    .part-image {
      width: 50px;
      height: 50px;
    }

    .cluster-container {
      margin-top: 20px;
      border: 1px solid black;
      padding: 10px;
    }

    .cluster-container h3 {
      margin-top: 0;
    }

    .cluster-container table {
      border-collapse: collapse;
      width: 100%;
    }

    .cluster-container table th, .cluster-container table td {
      border: 1px solid black;
      padding: 5px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div>Teachable Machine Image Model</div>
  <input type="file" id="imageUpload" accept="image/*">
  <button type="button" onclick="uploadImage()">Upload Image</button>

  <div id="results-container">
    <table id="results-table">
      <thead>
        <tr>
          <th>부분 이미지</th>
          <th>예측 결과</th>
          <th>군집</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
  <script type="text/javascript">
    // Teachable Machine 모델 경로
    const URL = "./my_model/";

    let model, resultsContainer, resultsTable;

    async function init() {
      const modelURL = URL + "model.json";
      const metadataURL = URL + "metadata.json";

      model = await tmImage.load(modelURL, metadataURL);
      resultsContainer = document.getElementById("results-container");
      resultsTable = document.getElementById("results-table").getElementsByTagName("tbody")[0];
    }

    async function uploadImage() {
      const fileInput = document.getElementById('imageUpload');
      const file = fileInput.files[0];

      if (file) {
        const reader = new FileReader();
        reader.onload = async (event) => {
          const img = new Image();
          img.onload = async () => {
            // 이미지를 32등분 (조정 가능)
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const partWidth = img.width / 32; 
            const partHeight = img.height / 32;

            const predictions = {};
            const histograms = [];
            for (let i = 0; i < 32; i++) {
              const partCanvas = document.createElement('canvas');
              const partCtx = partCanvas.getContext('2d');
              partCanvas.width = partWidth;
              partCanvas.height = partHeight;
              partCtx.drawImage(canvas, i * partWidth, 0, partWidth, img.height, 0, 0, partWidth, partHeight);

              // Teachable Machine 모델로 예측
              const prediction = await model.predict(partCanvas);
              const probability = prediction[0].probability.toFixed(2);

              // 결과 출력
              const row = resultsTable.insertRow();
              const partImageCell = row.insertCell();
              const partImage = document.createElement("img");
              partImage.src = partCanvas.toDataURL('image/png');
              partImage.classList.add("part-image");
              partImageCell.appendChild(partImage);
              const resultCell = row.insertCell();
              resultCell.textContent = `a_${i + 1}: ${probability}`;

              // 예측 결과 저장
              predictions[`a_${i + 1}`] = parseFloat(probability); 

              // 히스토그램 계산 (밝기 히스토그램 사용)
              const imageData = partCtx.getImageData(0, 0, partWidth, partHeight);
              const histogram = calculateHistogram(imageData);
              histograms.push(histogram);
            }

            // K-Means 군집화 (2개 군집)
            const clusters = kMeansClustering(histograms, 2); // 군집 개수 2개로 변경

            // 호랑이 확률 기반 군집 할당
            for (let i = 0; i < 32; i++) { // 이미지 부분 개수 32로 변경
              const clusterIndex = clusters.findIndex(cluster => cluster.includes(i));
              // 호랑이 확률이 0.7 이상인 경우 Cluster 1로 강제 할당
              if (predictions[`a_${i + 1}`] >= 0.7) {
                clusters[clusterIndex][clusters[clusterIndex].indexOf(i)] = 0; // Cluster 1 인덱스 (0)으로 변경
              }
              const clusterCell = resultsTable.rows[i].insertCell();
              clusterCell.textContent = `Cluster ${clusterIndex + 1}`;
            }

            // a_1~a_32 예측 결과를 localStorage에 저장
            localStorage.setItem("predictions", JSON.stringify(predictions));

            // 군집별로 부분 이미지 분류 및 표시
            displayClusteredImages(clusters, predictions);

            // 이미지 병합 및 재분류
            await mergeAndReclassifyImages(canvas, predictions, partWidth, partHeight);

            // fire.html로 이동
           // window.location.href = "fire.html";
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    }

    // 히스토그램 계산
    function calculateHistogram(imageData) {
      const histogram = new Array(256).fill(0); // 밝기 값 0~255 까지 히스토그램 생성
      for (let i = 0; i < imageData.data.length; i += 4) {
        const brightness = imageData.data[i]; // 밝기 값
        histogram[brightness]++;
      }
      return histogram;
    }

    // 히스토그램 비교 (SSD 사용)
    function compareHistograms(histogram1, histogram2) {
      let ssd = 0;
      for (let i = 0; i < histogram1.length; i++) {
        ssd += Math.pow(histogram1[i] - histogram2[i], 2);
      }
      return ssd;
    }

    // K-Means 군집화 (간단한 구현)
    function kMeansClustering(histograms, k = 2) { // 군집 개수 2개로 변경
      // 1. 임의의 중심점 (centroids) 선택 (히스토그램을 이용)
      const centroids = [];
      for (let i = 0; i < k; i++) {
        centroids.push(histograms[Math.floor(Math.random() * histograms.length)]);
      }

      // 2. 반복:
      //   - 각 부분 이미지 히스토그램을 가장 가까운 중심점에 할당
      //   - 각 군집의 중심점을 재계산
      let iterations = 0;
      let clusters = []; // clusters 변수 선언
      while (iterations < 10) { // 최대 반복 횟수 설정
        clusters = []; // 각 반복 시작 시 clusters 초기화
        for (let i = 0; i < k; i++) {
          clusters.push([]);
        }

        // 각 부분 이미지 히스토그램을 가장 가까운 중심점에 할당
        for (let i = 0; i < histograms.length; i++) {
          let closestCentroidIndex = 0;
          let minDistance = Infinity;
          for (let j = 0; j < centroids.length; j++) {
            const distance = compareHistograms(histograms[i], centroids[j]);
            if (distance < minDistance) {
              minDistance = distance;
              closestCentroidIndex = j;
            }
          }
          clusters[closestCentroidIndex].push(i);
        }

        // 각 군집의 중심점을 재계산
        for (let i = 0; i < k; i++) {
          if (clusters[i].length > 0) {
            centroids[i] = calculateAverageHistogram(clusters[i].map(index => histograms[index]));
          }
        }
        iterations++;
      }

      // 3. 군집 결과 반환
      return clusters;
    }

    function calculateAverageHistogram(histograms) {
      const averageHistogram = new Array(256).fill(0);
      for (let i = 0; i < histograms.length; i++) {
        for (let j = 0; j < 256; j++) {
          averageHistogram[j] += histograms[i][j];
        }
      }
      for (let j = 0; j < 256; j++) {
        averageHistogram[j] /= histograms.length;
      }
      return averageHistogram;
    }

    // 군집별로 부분 이미지 분류 및 표시
    function displayClusteredImages(clusters, predictions) {
      for (let i = 0; i < clusters.length; i++) {
        const clusterContainer = document.createElement("div");
        clusterContainer.classList.add("cluster-container");
        clusterContainer.innerHTML = `<h3>Cluster ${i + 1}</h3>
                                    <table>
                                      <thead>
                                        <tr>
                                          <th>부분 이미지</th>
                                          <th>예측 결과</th>
                                        </tr>
                                      </thead>
                                      <tbody>
                                      </tbody>
                                    </table>`;

        const clusterTable = clusterContainer.getElementsByTagName("tbody")[0];

        for (let j = 0; j < clusters[i].length; j++) {
          const partIndex = clusters[i][j];
          const predictionKey = `a_${partIndex + 1}`;
          const probability = predictions[predictionKey].toFixed(2);

          const row = clusterTable.insertRow();
          const partImageCell = row.insertCell();
          const partImage = document.createElement("img");
          partImage.src = resultsTable.rows[partIndex].cells[0].firstChild.src;
          partImage.classList.add("part-image");
          partImageCell.appendChild(partImage);
          const resultCell = row.insertCell();
          resultCell.textContent = `${predictionKey}: ${probability}`;
        }

        resultsContainer.appendChild(clusterContainer);
      }
    }

    // 이미지 병합 및 재분류
    async function mergeAndReclassifyImages(originalCanvas, predictions, partWidth, partHeight) {
      const mergedImages = [];
      for (let i = 0; i < 32; i++) {
        if (predictions[`a_${i + 1}`] >= 0.4) { // 유망한 조각 선택 (임계값 0.4)
          const mergedImage = {
            parts: [i], // 병합된 조각 목록
            probability: predictions[`a_${i + 1}`] // 초기 확률
          };

          // 주변 조각 병합 (확률 기반 선택)
          const neighborIndices = [i - 1, i + 1, i - 8, i + 8]; 
          for (const neighborIndex of neighborIndices) {
            if (neighborIndex >= 0 && neighborIndex < 32 && predictions[`a_${neighborIndex + 1}`] >= 0.2) { // 임계값 0.2로 주변 조각 선택
              mergedImage.parts.push(neighborIndex);
              mergedImage.probability += predictions[`a_${neighborIndex + 1}`];
              
              // 최대 크기 제한 (예: 8x8 조각)
              if (mergedImage.parts.length >= 8) {
                break; 
              }
            }
          }

          mergedImages.push(mergedImage);
        }
      }

      // 병합 이미지 판별 및 결과 판단
      for (const mergedImage of mergedImages) {
        const mergedCanvas = createMergedCanvas(mergedImage.parts, partWidth, partHeight, originalCanvas);
        const mergedPrediction = await model.predict(mergedCanvas);
        const mergedProbability = mergedPrediction[0].probability.toFixed(2);

        if (parseFloat(mergedProbability) > mergedImage.probability) {
          // 병합 성공 (확률 증가)
          console.log(`병합 성공! 확률: ${mergedProbability}`);
          // mergedCanvas를 사용하여 결과 처리 
        } else {
          // 병합 실패 (확률 감소)
          console.log(`병합 실패! 확률: ${mergedProbability}`);
          // 원래 조각 (mergedImage.parts) 을 사용하여 결과 처리 
        }
      }
    }

    function createMergedCanvas(partIndices, partWidth, partHeight, originalCanvas) {
      // 병합된 이미지를 생성하는 함수
      // partIndices: 병합할 조각 인덱스 목록
      // partWidth, partHeight: 각 조각의 너비와 높이
      // originalCanvas: 원본 이미지 캔버스

      const mergedCanvas = document.createElement('canvas');
      const mergedCtx = mergedCanvas.getContext('2d');

      let maxWidth = 0;
      let maxHeight = 0;

      for (const partIndex of partIndices) {
        const row = Math.floor(partIndex / 8); // 행 계산
        const col = partIndex % 8; // 열 계산

        maxWidth = Math.max(maxWidth, col + 1);
        maxHeight = Math.max(maxHeight, row + 1);
      }

      mergedCanvas.width = maxWidth * partWidth;
      mergedCanvas.height = maxHeight * partHeight;

      for (let i = 0; i < partIndices.length; i++) {
        const partIndex = partIndices[i];
        const row = Math.floor(partIndex / 8);
        const col = partIndex % 8;

        mergedCtx.drawImage(originalCanvas, 
                           col * partWidth, row * partHeight, partWidth, partHeight, 
                           col * partWidth, row * partHeight, partWidth, partHeight);
      }

      return mergedCanvas;
    }

    init();
  </script>
</body>
</html>

-->


<!-- 
    병합을 하긴 했는데 좀 별로인듯


    <!DOCTYPE html>
  <html>
  <head>
    <title>Teachable Machine Image Classifier</title>
    <style>
      #results-container {
        margin-top: 20px;
      }
  
      #results-table {
        border-collapse: collapse;
        width: 100%;
      }
  
      #results-table th, #results-table td {
        border: 1px solid black;
        padding: 5px;
        text-align: center;
      }
  
      #results-table th {
        background-color: #f2f2f2;
      }
  
      .part-image {
        width: 50px;
        height: 50px;
      }
  
      .cluster-container {
        margin-top: 20px;
        border: 1px solid black;
        padding: 10px;
      }
  
      .cluster-container h3 {
        margin-top: 0;
      }
  
      .cluster-container table {
        border-collapse: collapse;
        width: 100%;
      }
  
      .cluster-container table th, .cluster-container table td {
        border: 1px solid black;
        padding: 5px;
        text-align: center;
      }
  
      #merged-images-container {
        margin-top: 20px;
      }
  
      #merged-images-container img {
        width: 200px;
        height: 200px;
        margin: 5px;
        border: 1px solid black;
      }
  
      .merged-success {
        border: 2px solid green; /* 병합 성공 시 녹색 테두리 */
      }
  
      .merged-failure {
        border: 2px solid red; /* 병합 실패 시 빨간색 테두리 */
      }
  
      #final-results-container {
        margin-top: 20px;
      }
  
      #final-results-container table {
        border-collapse: collapse;
        width: 100%;
      }
  
      #final-results-container table th, #final-results-container table td {
        border: 1px solid black;
        padding: 5px;
        text-align: center;
      }
  
      #final-results-container table th {
        background-color: #f2f2f2;
      }
  
      #final-results-container img {
        width: 200px;
        height: 200px;
      }
    </style>
  </head>
  <body>
    <div>Teachable Machine Image Model</div>
    <input type="file" id="imageUpload" accept="image/*">
    <button type="button" onclick="uploadImage()">Upload Image</button>
  
    <div id="results-container">
      <table id="results-table">
        <thead>
          <tr>
            <th>부분 이미지</th>
            <th>예측 결과</th>
            <th>군집</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
    </div>
  
    <div id="merged-images-container">
      </div>
  
    <div id="final-results-container">
      <h3>최종 결과</h3>
      <table id="final-results-table">
        <thead>
          <tr>
            <th>이미지</th>
            <th>예측 결과</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
    </div>
  
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <script type="text/javascript">
      // Teachable Machine 모델 경로
      const URL = "./my_model/";
  
      let model, resultsContainer, resultsTable, mergedImagesContainer, finalResultsContainer, finalResultsTable;
  
      async function init() {
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";
  
        model = await tmImage.load(modelURL, metadataURL);
        resultsContainer = document.getElementById("results-container");
        resultsTable = document.getElementById("results-table").getElementsByTagName("tbody")[0];
        mergedImagesContainer = document.getElementById("merged-images-container");
        finalResultsContainer = document.getElementById("final-results-container");
        finalResultsTable = document.getElementById("final-results-table").getElementsByTagName("tbody")[0];
      }
  
      async function uploadImage() {
        const fileInput = document.getElementById('imageUpload');
        const file = fileInput.files[0];
  
        if (file) {
          const reader = new FileReader();
          reader.onload = async (event) => {
            const img = new Image();
            img.onload = async () => {
              // 이미지를 32등분 (조정 가능)
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);
  
              const partWidth = img.width / 32;
              const partHeight = img.height / 32;
  
              const predictions = {};
              const histograms = [];
              for (let i = 0; i < 32; i++) {
                const partCanvas = document.createElement('canvas');
                const partCtx = partCanvas.getContext('2d');
                partCanvas.width = partWidth;
                partCanvas.height = partHeight;
                partCtx.drawImage(canvas, i * partWidth, 0, partWidth, img.height, 0, 0, partWidth, partHeight);
  
                // Teachable Machine 모델로 예측
                const prediction = await model.predict(partCanvas);
                const probability = prediction[0].probability.toFixed(2);
  
                // 결과 출력
                const row = resultsTable.insertRow();
                const partImageCell = row.insertCell();
                const partImage = document.createElement("img");
                partImage.src = partCanvas.toDataURL('image/png');
                partImage.classList.add("part-image");
                partImageCell.appendChild(partImage);
                const resultCell = row.insertCell();
                resultCell.textContent = `a_${i + 1}: ${probability}`;
  
                // 예측 결과 저장
                predictions[`a_${i + 1}`] = parseFloat(probability);
  
                // 히스토그램 계산 (밝기 히스토그램 사용)
                const imageData = partCtx.getImageData(0, 0, partWidth, partHeight);
                const histogram = calculateHistogram(imageData);
                histograms.push(histogram);
              }
  
              // K-Means 군집화 (2개 군집)
              const clusters = kMeansClustering(histograms, 2); // 군집 개수 2개로 변경
  
              // 호랑이 확률 기반 군집 할당
              for (let i = 0; i < 32; i++) { // 이미지 부분 개수 32로 변경
                const clusterIndex = clusters.findIndex(cluster => cluster.includes(i));
                // 호랑이 확률이 0.7 이상인 경우 Cluster 1로 강제 할당
                if (predictions[`a_${i + 1}`] >= 0.7) {
                  clusters[clusterIndex][clusters[clusterIndex].indexOf(i)] = 0; // Cluster 1 인덱스 (0)으로 변경
                }
                const clusterCell = resultsTable.rows[i].insertCell();
                clusterCell.textContent = `Cluster ${clusterIndex + 1}`;
              }
  
              // a_1~a_32 예측 결과를 localStorage에 저장
              localStorage.setItem("predictions", JSON.stringify(predictions));
  
              // 군집별로 부분 이미지 분류 및 표시
              displayClusteredImages(clusters, predictions);
  
              let mergedImages = []; // mergedImages 변수 선언
  
              // 이미지 병합 및 재분류
              await mergeAndReclassifyImages(canvas, predictions, partWidth, partHeight, mergedImages); // mergedImages를 함수에 전달
  
              // 최종 결과 표시
              displayFinalResults(predictions, mergedImages);
  
              // fire.html로 이동
              //window.location.href = "fire.html";
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      }
  
      // 히스토그램 계산
      function calculateHistogram(imageData) {
        const histogram = new Array(256).fill(0); // 밝기 값 0~256 까지 히스토그램 생성
        for (let i = 0; i < imageData.data.length; i += 4) {
          const brightness = imageData.data[i]; // 밝기 값
          histogram[brightness]++;
        }
        return histogram;
      }
  
      // 히스토그램 비교 (SSD 사용)
      function compareHistograms(histogram1, histogram2) {
        let ssd = 0;
        for (let i = 0; i < histogram1.length; i++) {
          ssd += Math.pow(histogram1[i] - histogram2[i], 2);
        }
        return ssd;
      }
  
      // K-Means 군집화 (간단한 구현)
      function kMeansClustering(histograms, k = 2) { // 군집 개수 2개로 변경
        // 1. 임의의 중심점 (centroids) 선택 (히스토그램을 이용)
        const centroids = [];
        for (let i = 0; i < k; i++) {
          centroids.push(histograms[Math.floor(Math.random() * histograms.length)]);
        }
  
        // 2. 반복:
        //   - 각 부분 이미지 히스토그램을 가장 가까운 중심점에 할당
        //   - 각 군집의 중심점을 재계산
        let iterations = 0;
        let clusters = []; // clusters 변수 선언
        while (iterations < 10) { // 최대 반복 횟수 설정
          clusters = []; // 각 반복 시작 시 clusters 초기화
          for (let i = 0; i < k; i++) {
            clusters.push([]);
          }
  
          // 각 부분 이미지 히스토그램을 가장 가까운 중심점에 할당
          for (let i = 0; i < histograms.length; i++) {
            let closestCentroidIndex = 0;
            let minDistance = Infinity;
            for (let j = 0; j < centroids.length; j++) {
              const distance = compareHistograms(histograms[i], centroids[j]);
              if (distance < minDistance) {
                minDistance = distance;
                closestCentroidIndex = j;
              }
            }
            clusters[closestCentroidIndex].push(i);
          }
  
          // 각 군집의 중심점을 재계산
          for (let i = 0; i < k; i++) {
            if (clusters[i].length > 0) {
              centroids[i] = calculateAverageHistogram(clusters[i].map(index => histograms[index]));
            }
          }
          iterations++;
        }
  
        // 3. 군집 결과 반환
        return clusters;
      }
  
      function calculateAverageHistogram(histograms) {
        const averageHistogram = new Array(256).fill(0);
        for (let i = 0; i < histograms.length; i++) {
          for (let j = 0; j < 256; j++) {
            averageHistogram[j] += histograms[i][j];
          }
        }
        for (let j = 0; j < 256; j++) {
          averageHistogram[j] /= histograms.length;
        }
        return averageHistogram;
      }
  
      // 군집별로 부분 이미지 분류 및 표시
      function displayClusteredImages(clusters, predictions) {
        for (let i = 0; i < clusters.length; i++) {
          const clusterContainer = document.createElement("div");
          clusterContainer.classList.add("cluster-container");
          clusterContainer.innerHTML = `<h3>Cluster ${i + 1}</h3>
                                      <table>
                                        <thead>
                                          <tr>
                                            <th>부분 이미지</th>
                                            <th>예측 결과</th>
                                          </tr>
                                        </thead>
                                        <tbody>
                                        </tbody>
                                      </table>`;
  
          const clusterTable = clusterContainer.getElementsByTagName("tbody")[0];
  
          for (let j = 0; j < clusters[i].length; j++) {
            const partIndex = clusters[i][j];
            const predictionKey = `a_${partIndex + 1}`;
            const probability = predictions[predictionKey].toFixed(2);
  
            const row = clusterTable.insertRow();
            const partImageCell = row.insertCell();
            const partImage = document.createElement("img");
            partImage.src = resultsTable.rows[partIndex].cells[0].firstChild.src;
            partImage.classList.add("part-image");
            partImageCell.appendChild(partImage);
            const resultCell = row.insertCell();
            resultCell.textContent = `${predictionKey}: ${probability}`;
          }
  
          resultsContainer.appendChild(clusterContainer);
        }
      }
  
      // 이미지 병합 및 재분류
      async function mergeAndReclassifyImages(originalCanvas, predictions, partWidth, partHeight, mergedImages) { 
        // 가장 높은 확률을 가진 부분 이미지 찾기
        let highestProbability = 0;
        let highestIndex = -1;
        for (let i = 0; i < 32; i++) {
          if (predictions[`a_${i + 1}`] > highestProbability) {
            highestProbability = predictions[`a_${i + 1}`];
            highestIndex = i;
          }
        }
  
        if (highestIndex !== -1) {
          const initialMergedImage = {
            parts: [highestIndex],
            probability: highestProbability,
            mergedCanvas: null
          };
  
          // 가장 높은 확률 이미지를 시작으로 병합 반복
          while (true) {
            const mergedCanvas = createMergedCanvas(initialMergedImage.parts, partWidth, partHeight, originalCanvas);
            initialMergedImage.mergedCanvas = mergedCanvas; 
  
            // 주변 인접 이미지들과 병합 시도
            const neighborIndices = [
              highestIndex - 1, highestIndex + 1, 
              highestIndex - 8, highestIndex + 8
            ];
            let merged = false;
            for (const neighborIndex of neighborIndices) {
              if (neighborIndex >= 0 && neighborIndex < 32 && 
                  !initialMergedImage.parts.includes(neighborIndex)) {
                const mergedParts = [...initialMergedImage.parts, neighborIndex];
                const mergedCanvas = createMergedCanvas(mergedParts, partWidth, partHeight, originalCanvas);
                const mergedPrediction = await model.predict(mergedCanvas);
                const mergedProbability = mergedPrediction[0].probability.toFixed(2);
  
                if (parseFloat(mergedProbability) > initialMergedImage.probability) {
                  // 병합 성공 (확률 증가)
                  console.log(`병합 성공! 확률: ${mergedProbability}`);
                  initialMergedImage.parts = mergedParts;
                  initialMergedImage.probability = parseFloat(mergedProbability);
                  initialMergedImage.mergedCanvas = mergedCanvas; 
                  merged = true; 
                  break; // 성공적인 병합 후 반복 종료
                }
              }
            }
  
            // 병합 결과 시각화
            const mergedImageElement = document.createElement("img");
            mergedImageElement.src = initialMergedImage.mergedCanvas.toDataURL('image/png');
            mergedImageElement.classList.add(merged ? "merged-success" : "merged-failure");
            mergedImagesContainer.appendChild(mergedImageElement);
  
            // 병합 결과 문자열 생성
            const mergedPartsStr = initialMergedImage.parts.map(index => `a_${index + 1}`).join("+");
  
            // 병합 결과 표시 (예: "a_1+a_2")
            console.log(`병합된 부분 이미지: ${mergedPartsStr}`);
  
            // 확률이 더 이상 증가하지 않으면 반복 종료
            if (!merged) {
              break;
            }
          }
  
          mergedImages.push(initialMergedImage);
        }
      }
  
      function createMergedCanvas(partIndices, partWidth, partHeight, originalCanvas) {
        // 병합된 이미지를 생성하는 함수
        // partIndices: 병합할 조각 인덱스 목록
        // partWidth, partHeight: 각 조각의 너비와 높이
        // originalCanvas: 원본 이미지 캔버스
  
        const mergedCanvas = document.createElement('canvas');
        const mergedCtx = mergedCanvas.getContext('2d');
  
        let maxWidth = 0;
        let maxHeight = 0;
  
        for (const partIndex of partIndices) {
          const row = Math.floor(partIndex / 8); // 행 계산
          const col = partIndex % 8; // 열 계산
  
          maxWidth = Math.max(maxWidth, col + 1);
          maxHeight = Math.max(maxHeight, row + 1);
        }
  
        mergedCanvas.width = maxWidth * partWidth;
        mergedCanvas.height = maxHeight * partHeight;
  
        for (let i = 0; i < partIndices.length; i++) {
          const partIndex = partIndices[i];
          const row = Math.floor(partIndex / 8);
          const col = partIndex % 8;
  
          mergedCtx.drawImage(originalCanvas,
                             col * partWidth, row * partHeight, partWidth, partHeight,
                             col * partWidth, row * partHeight, partWidth, partHeight);
        }
  
        return mergedCanvas;
      }
  
      // 최종 결과 표시
      function displayFinalResults(predictions, mergedImages) {
        // 확률 0.8 이상인 단일 이미지 또는 병합된 이미지 표시
        for (let i = 1; i <= 32; i++) {
          const predictionKey = `a_${i}`;
          if (predictions[predictionKey] >= 0.8) {
            const row = finalResultsTable.insertRow();
            const imageCell = row.insertCell();
            const partImage = document.createElement("img");
            partImage.src = resultsTable.rows[i - 1].cells[0].firstChild.src;
            imageCell.appendChild(partImage);
            const resultCell = row.insertCell();
            resultCell.textContent = `${predictionKey}: ${predictions[predictionKey].toFixed(2)}`;
          }
        }
  
        // 병합된 이미지 중 확률 0.8 이상인 이미지 표시
        mergedImages.forEach(mergedImage => {
          if (mergedImage.probability >= 0.8) {
            const row = finalResultsTable.insertRow();
            const imageCell = row.insertCell();
            const partImage = document.createElement("img");
            partImage.src = mergedImage.mergedCanvas.toDataURL('image/png');
            imageCell.appendChild(partImage);
            const resultCell = row.insertCell();
            const mergedParts = mergedImage.parts.map(index => `a_${index + 1}`).join("+");
            resultCell.textContent = `${mergedParts}: ${mergedImage.probability.toFixed(2)}`;
          }
        });
      }
  
      init();
    </script>
  </body>
  </html>

-->


<!--

자꾸 병합할 때 currnetPart 로 바꾸면 오류나는

<!DOCTYPE html>
<html>
<head>
  <title>Teachable Machine Image Classifier with Merging</title>
  <style>
    #results-container {
      margin-top: 20px;
    }

    #results-table {
      border-collapse: collapse;
      width: 100%;
    }

    #results-table th, #results-table td {
      border: 1px solid black;
      padding: 5px;
      text-align: center;
    }

    #results-table th {
      background-color: #f2f2f2;
    }

    .part-image {
      width: 100px;
      height: 100px;
    }

    #merged-image {
      margin-top: 20px;
    }

    #merge-animation {
      width: 400px; /* 애니메이션 영역 크기 */
      height: 400px; /* 애니메이션 영역 크기 */
      border: 1px solid black;
      margin-top: 20px;
      position: relative; /* 자식 요소를 위치 지정하기 위해 */
    }

    .animation-part {
      position: absolute; /* 애니메이션 요소를 위치 지정하기 위해 */
      transition: all 0.5s ease; /* 애니메이션 전환 */
    }
  </style>
</head>
<body>
  <div>Teachable Machine Image Model with Merging</div>
  <input type="file" id="imageUpload" accept="image/*">
  <button type="button" onclick="uploadImage()">Upload Image</button>

  <div id="results-container">
    <table id="results-table">
      <thead>
        <tr>
          <th>부분 이미지</th>
          <th>예측 결과</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </div>

  <div id="merged-image">
    <h2>병합된 이미지:</h2>
    <img id="final-merged-image" src="" alt="병합된 이미지" style="max-width: 100%; height: auto;">
    <div id="merge-log"></div>
  </div>

  <div id="merge-animation"></div> 
애니메이션 영역

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
  <script type="text/javascript">
    const URL = "./my_model/"; // 모델 파일 경로

    let model, resultsContainer, resultsTable, mergedImageContainer, finalMergedImage, mergeLog, mergeAnimation;

    async function init() {
      const modelURL = URL + "model.json";
      const metadataURL = URL + "metadata.json";

      model = await tmImage.load(modelURL, metadataURL);
      resultsContainer = document.getElementById("results-container");
      resultsTable = document.getElementById("results-table").getElementsByTagName("tbody")[0];
      mergedImageContainer = document.getElementById("merged-image");
      finalMergedImage = document.getElementById("final-merged-image");
      mergeLog = document.getElementById("merge-log");
      mergeAnimation = document.getElementById("merge-animation");
    }

    async function uploadImage() {
      const fileInput = document.getElementById('imageUpload');
      const file = fileInput.files[0];

      if (file) {
        const reader = new FileReader();
        reader.onload = async (event) => {
          const img = new Image();
          img.onload = async () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            let parts = []; // parts 변수를 let으로 선언
            const partWidth = img.width / 10; // 10개로 등분
            const partHeight = img.height / 10;
            let partIndex = 1; // 부분 이미지 이름을 위한 인덱스

            for (let i = 0; i < 10; i++) {
              for (let j = 0; j < 10; j++) {
                const partCanvas = document.createElement('canvas');
                const partCtx = partCanvas.getContext('2d');
                partCanvas.width = partWidth;
                partCanvas.height = partHeight;
                partCtx.drawImage(canvas, i * partWidth, j * partHeight, partWidth, partHeight, 0, 0, partWidth, partHeight);

                const prediction = await model.predict(partCanvas);
                const probability = prediction[0].probability.toFixed(2);

                parts.push({
                  canvas: partCanvas,
                  probability: parseFloat(probability),
                  x: i, // x 좌표
                  y: j, // y 좌표
                  name: `a_${partIndex}` // 부분 이미지 이름
                });
                partIndex++;
              }
            }

            // 병합 작업 시작
            let mergedPart = null;
            let mergeCount = 0;
            while (mergeCount < 8) { // 최대 8번 시도
              // 가장 확률이 높은 부분 이미지 찾기
              const highestProbabilityPart = parts.reduce((max, part) => part.probability > max.probability ? part : max, parts[0]);

              if (highestProbabilityPart) {
                // mergeParts 함수에서 반환된 값을 mergedPart에 할당
                mergedPart = await mergeParts(highestProbabilityPart, parts);
                // parts 배열을 새롭게 생성하고 할당
                parts = parts.filter(part => part.name !== highestProbabilityPart.name);
                mergeCount++;
              } else {
                break; // 더 이상 병합할 부분 이미지가 없으면 종료
              }
            }

            // 병합된 이미지 출력
            if (mergedPart) {
              finalMergedImage.src = mergedPart.canvas.toDataURL('image/png');
            }

            // 결과 표시 (테이블)
            resultsTable.innerHTML = '';
            parts.forEach(part => {
              const row = resultsTable.insertRow();
              const partImageCell = row.insertCell();
              const partImage = document.createElement("img");
              partImage.src = part.canvas.toDataURL('image/png');
              partImage.classList.add("part-image");
              partImageCell.appendChild(partImage);
              const resultCell = row.insertCell();
              resultCell.textContent = `${part.name}: ${part.probability}`;
            });
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    }

    async function mergeParts(targetPart, allParts) {
      let currentPart = targetPart; // currentPart 변수를 정의
      let mergeHistory = []; // 병합 기록
      let mergeAttempts = 0; // 병합 시도 횟수

      // 최대 10번 시도하거나, 확률이 1.0에 도달하면 종료
      while (mergeAttempts < 10 && currentPart.probability < 1.0) { 
        // 인접한 부분 이미지 찾기
        const adjacentParts = getAdjacentParts(currentPart, allParts);

        // 매번 가장 확률이 높은 인접 이미지를 찾습니다.
        const highestProbabilityAdjacentPart = adjacentParts.reduce((max, part) => part.probability > max.probability ? part : max, adjacentParts[0]);

        // 병합 가능성 확인
        if (highestProbabilityAdjacentPart) {
          const mergedCanvas = mergeCanvases(currentPart.canvas, highestProbabilityAdjacentPart.canvas);
          const mergedPrediction = await model.predict(mergedCanvas);
          const mergedProbability = mergedPrediction[0].probability.toFixed(2);

          console.log(`현재 확률: ${currentPart.probability}, 병합 대상 확률: ${highestProbabilityAdjacentPart.probability}`); // 현재 확률 출력

          // 규칙 1: 병합된 이미지의 확률이 더 높으면 성공
          if (parseFloat(mergedProbability) > currentPart.probability) {
            // 병합 성공
            // 새 객체 생성하여 parts 배열에 추가 (중복 확인)
            const newPartName = `${currentPart.name}+${highestProbabilityAdjacentPart.name}`;
            if (!allParts.some(part => part.name === newPartName)) { // 이미 존재하는 이름이 아니면 추가
              const newPart = {
                canvas: mergedCanvas,
                probability: parseFloat(mergedProbability),
                x: Math.min(currentPart.x, highestProbabilityAdjacentPart.x), // x 좌표 조정
                y: Math.min(currentPart.y, highestProbabilityAdjacentPart.y), // y 좌표 조정
                name: newPartName // 이름 병합
              };
              // targetPart를 제거하고 새 part 추가
              const targetIndex = allParts.findIndex(part => part.name === targetPart.name);
              allParts.splice(targetIndex, 1, newPart);
              currentPart = newPart;
            }

            mergeHistory.push(`${currentPart.name}는 ${highestProbabilityAdjacentPart.name}와 병합됨 (확률: ${mergedProbability})`);
            console.log(`병합 성공: ${currentPart.name} (${mergedProbability})`);
            mergeAttempts = 0; // 병합 성공 시 시도 횟수 초기화

            // 병합 애니메이션 추가 (새로운 이미지를 보여줍니다.)
            animateMerge(currentPart, highestProbabilityAdjacentPart, mergedCanvas);
          }

          // 규칙 2: 병합된 이미지의 확률이 0.3 이상이면 성공
          else if (parseFloat(mergedProbability) >= 0.3) {
            // 병합 성공
            // 새 객체 생성하여 parts 배열에 추가 (중복 확인)
            const newPartName = `${currentPart.name}+${highestProbabilityAdjacentPart.name}`;
            if (!allParts.some(part => part.name === newPartName)) { // 이미 존재하는 이름이 아니면 추가
              const newPart = {
                canvas: mergedCanvas,
                probability: parseFloat(mergedProbability),
                x: Math.min(currentPart.x, highestProbabilityAdjacentPart.x), // x 좌표 조정
                y: Math.min(currentPart.y, highestProbabilityAdjacentPart.y), // y 좌표 조정
                name: newPartName // 이름 병합
              };
              // targetPart를 제거하고 새 part 추가
              const targetIndex = allParts.findIndex(part => part.name === targetPart.name);
              allParts.splice(targetIndex, 1, newPart);
              currentPart = newPart;
            }

            mergeHistory.push(`${currentPart.name}는 ${highestProbabilityAdjacentPart.name}와 병합됨 (확률: ${mergedProbability})`);
            console.log(`병합 성공: ${currentPart.name} (${mergedProbability})`);
            mergeAttempts = 0; // 병합 성공 시 시도 횟수 초기화

            // 병합 애니메이션 추가 (새로운 이미지를 보여줍니다.)
            animateMerge(currentPart, highestProbabilityAdjacentPart, mergedCanvas);
          }

          // 규칙 1, 2 모두 만족하지 못하면 실패
          else {
            mergeHistory.push(`${currentPart.name}는 ${highestProbabilityAdjacentPart.name}와 병합 실패 (확률: ${mergedProbability})`);
            console.log(`병합 실패: ${highestProbabilityAdjacentPart.name} (확률: ${mergedProbability})`);
            mergeAttempts++; // 병합 실패 시 시도 횟수 증가
          }
        } else {
          // 인접한 부분 이미지 없음
          mergeHistory.push(`병합 실패 (인접한 부분 이미지 없음)`);
          console.log(`병합 실패: 인접한 부분 이미지 없음`);
          mergeAttempts++; // 병합 실패 시 시도 횟수 증가
        }
      }

      // 병합 기록 출력
      mergeHistory.forEach(record => {
        const logItem = document.createElement("p");
        logItem.textContent = record;
        mergeLog.appendChild(logItem);
      });

      // 마지막 병합 결과를 반환
      return currentPart; 
    }

    function getAdjacentParts(targetPart, allParts) {
      const adjacentParts = [];
      const x = targetPart.x;
      const y = targetPart.y;

      // 상하좌우 인접 부분 이미지 확인
      if (y > 0) { // 위
        const abovePart = allParts[x + y * 10 - 10];
        if (abovePart && !abovePart.name.includes(targetPart.name)) { // 이미 병합된 이미지가 아니면 추가
          adjacentParts.push(abovePart);
        }
      }
      if (y < 9) { // 아래
        const belowPart = allParts[x + y * 10 + 10];
        if (belowPart && !belowPart.name.includes(targetPart.name)) { // 이미 병합된 이미지가 아니면 추가
          adjacentParts.push(belowPart);
        }
      }
      if (x > 0) { // 왼쪽
        const leftPart = allParts[x - 1 + y * 10];
        if (leftPart && !leftPart.name.includes(targetPart.name)) { // 이미 병합된 이미지가 아니면 추가
          adjacentParts.push(leftPart);
        }
      }
      if (x < 9) { // 오른쪽
        const rightPart = allParts[x + 1 + y * 10];
        if (rightPart && !rightPart.name.includes(targetPart.name)) { // 이미 병합된 이미지가 아니면 추가
          adjacentParts.push(rightPart);
        }
      }

      return adjacentParts;
    }

    function mergeCanvases(canvas1, canvas2) {
      const mergedCanvas = document.createElement('canvas');
      const mergedCtx = mergedCanvas.getContext('2d');

      mergedCanvas.width = Math.max(canvas1.width, canvas2.width);
      mergedCanvas.height = Math.max(canvas1.height, canvas2.height);

      // canvas1을 왼쪽 위에 그리기
      mergedCtx.drawImage(canvas1, 0, 0);

      // canvas2를 오른쪽 아래에 그리기
      const dx = canvas1.width > canvas2.width ? 0 : canvas1.width;
      const dy = canvas1.height > canvas2.height ? 0 : canvas1.height;
      mergedCtx.drawImage(canvas2, dx, dy);

      return mergedCanvas;
    }

    // 병합 애니메이션 함수
    function animateMerge(part1, part2, mergedCanvas) {
      const animationPart1 = document.createElement("img");
      const animationPart2 = document.createElement("img");

      // 애니메이션 영역에 부분 이미지를 추가합니다.
      animationPart1.src = part1.canvas.toDataURL('image/png');
      animationPart1.classList.add("animation-part");
      animationPart1.style.left = `${part1.x * 100}px`; /* x 좌표를 사용하여 위치 지정 */
      animationPart1.style.top = `${part1.y * 100}px`; /* y 좌표를 사용하여 위치 지정 */
      mergeAnimation.appendChild(animationPart1);

      animationPart2.src = part2.canvas.toDataURL('image/png');
      animationPart2.classList.add("animation-part");
      animationPart2.style.left = `${part2.x * 100}px`; /* x 좌표를 사용하여 위치 지정 */
      animationPart2.style.top = `${part2.y * 100}px`; /* y 좌표를 사용하여 위치 지정 */
      mergeAnimation.appendChild(animationPart2);

      // 0.5초 후에 병합 애니메이션을 실행합니다.
      setTimeout(() => {
        animationPart1.style.left = "0px"; /* 왼쪽으로 이동 */
        animationPart1.style.top = "0px"; /* 위로 이동 */

        animationPart2.style.left = "0px"; /* 왼쪽으로 이동 */
        animationPart2.style.top = "0px"; /* 위로 이동 */
      }, 500);

      // 1초 후에 애니메이션 요소를 제거하고 병합된 이미지를 표시합니다.
      setTimeout(() => {
        mergeAnimation.innerHTML = ""; // 애니메이션 영역 초기화
        const mergedImage = document.createElement("img");
        mergedImage.src = mergedCanvas.toDataURL('image/png');
        mergedImage.style.width = "400px"; // 애니메이션 영역 크기와 동일하게 설정
        mergedImage.style.height = "400px"; // 애니메이션 영역 크기와 동일하게 설정
        mergeAnimation.appendChild(mergedImage);
      }, 1000);
    }

    init();
  </script>
</body>
</html>
-->